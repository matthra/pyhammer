import sys
import os
import uuid
import streamlit as st
import pandas as pd
import plotly.express as px

# 1. Setup Path
sys.path.append(os.path.abspath(os.path.dirname(__file__)))

# 2. Imports
try:
    from src.data.targets import TARGETS
    from src.data.rosters import DEFAULT_ROSTER
    from src.engine.calculator import calculate_group_metrics
    from src.engine.grading import get_cpk_grade, get_grade_color
    from src.visualizations.theme_utils import load_themes, get_unit_color_map
    from src.visualizations.charts import (
        plot_threat_matrix_interactive,
        plot_efficiency_curve_interactive,
        plot_strength_profile,
        plot_army_damage
    )
except ModuleNotFoundError as e:
    st.error(f"CRITICAL ERROR: Could not import modules. \n\nError Details: {e}")
    st.stop()

st.set_page_config(page_title="PyHammer 0.3.8", page_icon="‚ö°", layout="wide")

# --- SIDEBAR (Restored!) ---
with st.sidebar:
    st.title("‚ö° PyHammer v0.3.8")
    st.markdown("---")
    st.header("üéØ Analysis Focus")
    
    # Select a target for the "Army Summary" and Charts
    target_keys = list(TARGETS.keys())
    # Default to "Marine Equivalent" or first available
    default_idx = target_keys.index("Marine Equivalent") if "Marine Equivalent" in target_keys else 0
    
    col_target, col_cover = st.columns([3, 1])
    with col_target:
        selected_target_key = st.selectbox("Enemy Profile", target_keys, index=default_idx)
    with col_cover:
        st.markdown("<br>", unsafe_allow_html=True)  # Align with selectbox
        assume_cover = st.checkbox("ü™® Assume Cover", value=False, help="Apply +1 to save rolls for all targets")

    selected_target_stats = TARGETS[selected_target_key].copy()

    # Apply cover bonus if enabled
    if assume_cover:
        current_save = selected_target_stats.get('Sv', '7+')
        # Parse save value (e.g., "3+" ‚Üí 3)
        try:
            save_val = int(current_save.replace('+', ''))
            # Cover gives +1 to save (lower number is better)
            improved_save = max(2, save_val - 1)  # Can't be better than 2+
            selected_target_stats['Sv'] = f'{improved_save}+'
        except:
            pass  # If parsing fails, leave unchanged

    # Show Stats for context
    c1, c2, c3 = st.columns(3)
    c1.metric("T", selected_target_stats['T'])
    c2.metric("Sv", f"{selected_target_stats['Sv']}", help="‚úÖ Cover applied" if assume_cover else None)
    c3.metric("W", selected_target_stats.get('W', 1))
    
    st.markdown("---")
    st.caption("v0.3.8 RC1 - Optimization Engine Active")

# --- LOAD CONFIG ---
THEMES = load_themes()

# --- INITIAL DATA ---
if 'roster' not in st.session_state:
    # Now much cleaner!
    st.session_state['roster'] = pd.DataFrame(DEFAULT_ROSTER)

# --- ROBUST SANITIZATION ---
# 1. Retrieve data
raw_data = st.session_state.get('roster', pd.DataFrame())

if not isinstance(raw_data, pd.DataFrame):
    raw_df = pd.DataFrame()
else:
    raw_df = raw_data

if not raw_df.empty:
    # 1. Clean Numeric Columns
    if 'Pts' in raw_df.columns:
        raw_df['Pts'] = pd.to_numeric(raw_df['Pts'], errors='coerce').fillna(0)
    if 'Qty' in raw_df.columns:
        raw_df['Qty'] = pd.to_numeric(raw_df['Qty'], errors='coerce').fillna(1).astype(int)
    
    # 2. Clean Text Columns
    for col in ['Name', 'Weapon', 'Loadout Group', 'Profile ID']:
        if col in raw_df.columns:
            raw_df[col] = raw_df[col].astype(str).replace('nan', '')
            
    # 3. --- UNIT ID GENERATION (The Logic Fix) ---
    if 'UnitID' not in raw_df.columns:
        # LEGACY IMPORT DETECTED:
        # We assume rows with the exact same Name belong to the same Unit.
        # We assign a new random UUID to each unique Name group.
        raw_df['UnitID'] = raw_df.groupby('Name')['Name'].transform(lambda x: str(uuid.uuid4()))
    else:
        # If ID column exists but some rows are empty (partial data), fill them
        raw_df['UnitID'] = raw_df['UnitID'].fillna('').astype(str)
        mask_missing = raw_df['UnitID'] == ''
        if mask_missing.any():
            # Assign unique IDs to orphans to be safe
            raw_df.loc[mask_missing, 'UnitID'] = [str(uuid.uuid4()) for _ in range(mask_missing.sum())]

    # Filter invalid rows
    if 'Name' in raw_df.columns:
        active_roster = raw_df.dropna(subset=['Name']).copy()
        active_roster = active_roster[active_roster['Name'].str.strip() != '']
    else:
        active_roster = raw_df.copy()
else:
    active_roster = pd.DataFrame()

st.session_state['roster'] = active_roster
edited_df = active_roster

# 2. DEFENSIVE TYPE CHECK
if not isinstance(raw_data, pd.DataFrame):
    try:
        raw_df = pd.DataFrame(raw_data)
    except Exception:
        raw_df = pd.DataFrame()
else:
    raw_df = raw_data

# 3. Clean Columns
if not raw_df.empty:
    # Ensure Numeric Columns
    if 'Pts' in raw_df.columns:
        raw_df['Pts'] = pd.to_numeric(raw_df['Pts'], errors='coerce').fillna(0)
    
    if 'Qty' in raw_df.columns:
        raw_df['Qty'] = pd.to_numeric(raw_df['Qty'], errors='coerce').fillna(1).astype(int)
    else:
        raw_df['Qty'] = 1
        
    if 'Profile ID' in raw_df.columns:
        raw_df['Profile ID'] = raw_df['Profile ID'].astype(str).replace('nan', '')
    else:
        raw_df['Profile ID'] = ''

    # Filter out rows with no Name
    if 'Name' in raw_df.columns:
        active_roster = raw_df.dropna(subset=['Name']).copy()
        active_roster = active_roster[active_roster['Name'].astype(str).str.strip() != '']
    else:
        active_roster = raw_df.copy()
else:
    active_roster = pd.DataFrame()

# 4. Save back to state
st.session_state['roster'] = active_roster
# This 'active_roster' is what we use for the rest of the app
edited_df = active_roster 

# --- MAIN LAYOUT ---
st.title("‚öîÔ∏è Mathhammer Analysis")

# --- ARMY DASHBOARD ---
if not edited_df.empty:
    army_results = calculate_group_metrics(edited_df, selected_target_stats, deduplicate=False)
    army_df = pd.DataFrame(army_results)
    
    if not army_df.empty:
        total_dmg = army_df['Damage'].sum()
        total_kills = army_df['Kills'].sum()
        
        # --- POINTS FIX ---
        # We can't just sum(Pts * Qty) on the raw dataframe because of the duplicate rows.
        # Instead, we calculate it from our CLEAN 'army_results' which has already handled the grouping!
        
        # Each row in army_results represents a UNIT (with Qty applied).
        # We need to recalculate the total cost basis from that.
        # Logic: (Unit Pts * Qty) is implicitly what we want.
        # However, army_results doesn't return raw 'Pts', it used it for CPK.
        
        # Let's extract the cost from the CPK logic or re-calculate.
        # Re-calculating is safer:
        # Group raw DF by [Name, Qty], take MAX Pts, then Sum (Pts * Qty).
        
        pts_group = edited_df.groupby(['Name', 'Qty'])['Pts'].max().reset_index()
        roster_pts = (pts_group['Pts'] * pts_group['Qty']).sum()
        
        # Army Efficiency
        target_pts = selected_target_stats.get('Pts', 1)
        kill_value = total_kills * target_pts
        army_cpk = roster_pts / kill_value if kill_value > 0 else 0

        # KPI CARDS
        k1, k2, k3, k4 = st.columns(4)
        k1.metric("üõ°Ô∏è Total Army Points", f"{roster_pts}")
        k2.metric(f"üí• Damage vs {selected_target_key}", f"{total_dmg:.1f}")
        k3.metric(f"üíÄ Kills vs {selected_target_key}", f"{total_kills:.1f}")
        k4.metric("üìà Army CPK", f"{army_cpk:.2f}", delta_color="inverse")
    
    st.divider()

# --- UI TABS ---
tab_build, tab_cpk, tab_kills, tab_ttk, tab_viz = st.tabs([
    "üèóÔ∏è Roster Manager", 
    "üí∞ Efficiency (CPK)", 
    "üíÄ Lethality (Kills)", 
    "‚è±Ô∏è Time to Kill",
    "üìä Interactive Charts"
])

# --- TAB 1: BUILDER (Master-Detail View) ---
with tab_build:
    # 1. File Uploader
    def load_csv():
        if st.session_state.uploaded_file is not None:
            try:
                new_df = pd.read_csv(st.session_state.uploaded_file)
                # Ensure all columns are treated as strings to prevent TypeErrors
                cols_to_str = ['Name', 'Weapon', 'Loadout Group', 'Keywords', 'Profile ID', 'UnitID']
                for col in cols_to_str:
                    if col in new_df.columns:
                        new_df[col] = new_df[col].astype(str)
                st.session_state['roster'] = new_df
            except Exception as e:
                st.error(f"Error reading CSV: {e}")

    # Layout: Master List (Left) | Detail Editor (Right)
    c_list, c_detail = st.columns([1, 2])
    
    # --- LEFT: MASTER LIST ---
    with c_list:
        st.subheader("üìã My Units")
        
        if not st.session_state['roster'].empty:
            # 1. Prepare the Data
            # We group by UnitID to get unique entries
            grouped = st.session_state['roster'].groupby('UnitID').agg({
                'Name': 'first',
                'Qty': 'first',
                'Pts': 'first',
                'Weapon': 'count'
            }).reset_index()
            
            # 2. State Management for Selection
            # We use session_state to track which ID is 'active' across reruns
            if 'selected_unit_id' not in st.session_state:
                st.session_state['selected_unit_id'] = None

            # 3. Render Buttons (The "Navigation List")
            # We iterate through the units and create a button for each.
            for idx, row in grouped.iterrows():
                u_id = row['UnitID']
                
                # Calculate display values
                total_pts = row['Pts'] * row['Qty']
                label = f"{row['Name']} (x{row['Qty']}) - {total_pts}pts"
                
                # Determine button style (Highlight the active one)
                is_active = (u_id == st.session_state['selected_unit_id'])
                btn_type = "primary" if is_active else "secondary"
                
                # Render the button
                if st.button(label, key=f"btn_{u_id}", type=btn_type, use_container_width=True):
                    st.session_state['selected_unit_id'] = u_id
                    st.rerun()

            # Set the ID for the right panel to use
            active_unit_id = st.session_state['selected_unit_id']
            
        else:
            st.info("Roster is empty.")
            active_unit_id = None

        st.divider()
        
        # New Unit Button
        if st.button("‚ûï New Unit", use_container_width=True):
            new_id = str(uuid.uuid4())
            new_row = {
                'UnitID': new_id, 'Qty': 1, 'Name': 'New Unit', 'Pts': 100,
                'Weapon': 'New Weapon', 'Range': '24', 'A': '4', 'BS': '3', 'S': '4', 'AP': 0, 'D': '1',
                'Loadout Group': 'Ranged', 'Profile ID': '', 'Keywords': '',
                'CritHit': 6, 'CritWound': 6, 'Sustained': 0, 'Lethal': 'N', 'Dev': 'N',
                'Torrent': 'N', 'TwinLinked': 'N', 'Blast': 'N', 'Melta': 'N', 'RapidFire': 'N', 'RR_H': 'N', 'RR_W': 'N'
            }
            st.session_state['roster'] = pd.concat([st.session_state['roster'], pd.DataFrame([new_row])], ignore_index=True)
            # Auto-select the new unit
            st.session_state['selected_unit_id'] = new_id
            st.rerun()

        # CSV Controls
        st.download_button("üíæ Save CSV", st.session_state['roster'].to_csv(index=False).encode('utf-8'), "roster.csv", "text/csv", use_container_width=True)
        st.file_uploader("Import", type=['csv'], key="uploaded_file", on_change=load_csv, label_visibility="collapsed")

    # --- RIGHT: DETAIL EDITOR ---
    with c_detail:
        if active_unit_id:
            # Get all rows for this unit
            unit_mask = st.session_state['roster']['UnitID'] == active_unit_id
            unit_rows = st.session_state['roster'][unit_mask].copy()
            first_row = unit_rows.iloc[0]
            
            # --- HEADER (Shared Stats) ---
            st.subheader(f"üõ†Ô∏è Editing: {first_row['Name']}")
            
            with st.form("unit_header_form"):
                c1, c2, c3, c4 = st.columns([3, 1, 1, 1])
                u_name = c1.text_input("Unit Name", value=first_row['Name'])
                u_qty = c2.number_input("Qty", min_value=1, value=int(first_row['Qty']))
                u_pts = c3.number_input("Pts (per model)", min_value=0, value=int(first_row['Pts']))
                
                c4.markdown("<br>", unsafe_allow_html=True)
                delete_btn = c4.form_submit_button("üóëÔ∏è Delete Unit", type="primary")

                if st.form_submit_button("üíæ Update Unit Details"):
                    # Update ALL rows with this ID
                    st.session_state['roster'].loc[unit_mask, 'Name'] = u_name
                    st.session_state['roster'].loc[unit_mask, 'Qty'] = u_qty
                    st.session_state['roster'].loc[unit_mask, 'Pts'] = u_pts
                    st.success("Unit updated.")
                    st.rerun()
                
                if delete_btn:
                    # Remove all rows with this ID
                    st.session_state['roster'] = st.session_state['roster'][~unit_mask]
                    st.rerun()

            st.divider()
            
            # --- WEAPON EDITOR (Loop through rows) ---
            st.caption(f"Weapons ({len(unit_rows)})")
            
            for idx, row in unit_rows.iterrows():
                # Each weapon gets an Expander
                label = f"‚öîÔ∏è {row['Weapon']} ({row['Loadout Group']})"
                with st.expander(label, expanded=False):
                    with st.form(f"wep_form_{idx}"):
                        w_name = st.text_input("Weapon Name", value=row['Weapon'])
                        
                        c1, c2, c3 = st.columns(3)
                        w_type = c1.selectbox("Type", ["Ranged", "Melee"], index=0 if row['Loadout Group'] == 'Ranged' else 1)
                        w_rng = c2.text_input("Range", value=str(row['Range']))
                        w_pid = c3.text_input("Profile ID", value=str(row['Profile ID']), help="Use matching IDs for exclusive modes (e.g. 'Plasma')")
                        
                        s1, s2, s3, s4, s5 = st.columns(5)
                        w_a = s1.text_input("A", value=str(row['A']))
                        
                        # BS Handling
                        curr_bs = str(row['BS']).replace('+', '')
                        bs_opts = ["2", "3", "4", "5", "6", "N/A"]
                        bs_idx = bs_opts.index(curr_bs) if curr_bs in bs_opts else 1
                        w_bs = s2.selectbox("BS/WS", bs_opts, index=bs_idx)
                        
                        w_s = s3.text_input("S", value=str(row['S']))
                        
                        # AP Handling
                        curr_ap = int(row['AP']) if str(row['AP']).lstrip('-').isdigit() else 0
                        ap_opts = [0, -1, -2, -3, -4, -5, -6]
                        ap_idx = ap_opts.index(curr_ap) if curr_ap in ap_opts else 0
                        w_ap = s4.selectbox("AP", ap_opts, index=ap_idx)
                        
                        w_d = s5.text_input("D", value=str(row['D']))

                        # Keywords Section
                        st.caption("‚öôÔ∏è Keywords & Special Rules")
                        k1, k2, k3, k4 = st.columns(4)

                        # Get current values (with defaults)
                        curr_lethal = str(row.get('Lethal', 'N')).upper() == 'Y'
                        curr_dev = str(row.get('Dev', 'N')).upper() == 'Y'
                        curr_torrent = str(row.get('Torrent', 'N')).upper() == 'Y'
                        curr_twin = str(row.get('TwinLinked', 'N')).upper() == 'Y'

                        w_lethal = k1.checkbox("Lethal Hits", value=curr_lethal, help="Critical hits auto-wound")
                        w_dev = k2.checkbox("Devastating Wounds", value=curr_dev, help="Critical wounds become mortal wounds")
                        w_torrent = k3.checkbox("Torrent", value=curr_torrent, help="Auto-hit (ignores BS)")
                        w_twin = k4.checkbox("Twin-Linked", value=curr_twin, help="Reroll wound rolls")

                        k5, k6, k7, k8 = st.columns(4)
                        curr_blast = str(row.get('Blast', 'N')).upper() == 'Y'
                        w_blast = k5.checkbox("Blast", value=curr_blast, help="Bonus attacks vs large units (6+ models)")
                        curr_melta = str(row.get('Melta', 'N')).upper() == 'Y'
                        w_melta = k6.checkbox("Melta", value=curr_melta, help="Bonus damage at half range")
                        curr_rapid_fire = str(row.get('RapidFire', 'N')).upper() == 'Y'
                        w_rapid_fire = k7.checkbox("Rapid Fire", value=curr_rapid_fire, help="Double attacks at half range")
                        curr_sustained = int(row.get('Sustained', 0)) if str(row.get('Sustained', 0)).isdigit() else 0
                        w_sustained = k8.number_input("Sustained Hits", min_value=0, max_value=6, value=curr_sustained, help="Extra hits on critical")

                        # Advanced: Critical thresholds
                        with st.expander("üéØ Advanced: Critical Thresholds"):
                            t1, t2 = st.columns(2)
                            curr_crit_hit = int(row.get('CritHit', 6)) if str(row.get('CritHit', 6)).isdigit() else 6
                            curr_crit_wound = int(row.get('CritWound', 6)) if str(row.get('CritWound', 6)).isdigit() else 6
                            w_crit_hit = t1.number_input("Critical Hit", min_value=2, max_value=6, value=curr_crit_hit, help="Hit roll needed for crit")
                            w_crit_wound = t2.number_input("Critical Wound", min_value=2, max_value=6, value=curr_crit_wound, help="Wound roll needed for crit")

                        # Save/Delete
                        c_save, c_del = st.columns([1, 1])
                        save_wep = c_save.form_submit_button("Save Changes")
                        del_wep = c_del.form_submit_button("Remove Weapon", type="primary")

                        if save_wep:
                            st.session_state['roster'].at[idx, 'Weapon'] = w_name
                            st.session_state['roster'].at[idx, 'Loadout Group'] = w_type
                            st.session_state['roster'].at[idx, 'Range'] = w_rng
                            st.session_state['roster'].at[idx, 'Profile ID'] = w_pid
                            st.session_state['roster'].at[idx, 'A'] = w_a
                            st.session_state['roster'].at[idx, 'BS'] = w_bs
                            st.session_state['roster'].at[idx, 'S'] = w_s
                            st.session_state['roster'].at[idx, 'AP'] = w_ap
                            st.session_state['roster'].at[idx, 'D'] = w_d

                            # Save keywords
                            st.session_state['roster'].at[idx, 'Lethal'] = 'Y' if w_lethal else 'N'
                            st.session_state['roster'].at[idx, 'Dev'] = 'Y' if w_dev else 'N'
                            st.session_state['roster'].at[idx, 'Torrent'] = 'Y' if w_torrent else 'N'
                            st.session_state['roster'].at[idx, 'TwinLinked'] = 'Y' if w_twin else 'N'
                            st.session_state['roster'].at[idx, 'Blast'] = 'Y' if w_blast else 'N'
                            st.session_state['roster'].at[idx, 'Melta'] = 'Y' if w_melta else 'N'
                            st.session_state['roster'].at[idx, 'RapidFire'] = 'Y' if w_rapid_fire else 'N'
                            st.session_state['roster'].at[idx, 'Sustained'] = w_sustained
                            st.session_state['roster'].at[idx, 'CritHit'] = w_crit_hit
                            st.session_state['roster'].at[idx, 'CritWound'] = w_crit_wound

                            st.rerun()
                        
                        if del_wep:
                            st.session_state['roster'] = st.session_state['roster'].drop(idx).reset_index(drop=True)
                            st.rerun()

            # --- ADD NEW WEAPON ---
            if st.button("‚ûï Add Weapon Profile", use_container_width=True):
                new_wep = first_row.copy()
                new_wep['Weapon'] = "New Weapon"
                # Keep UnitID/Name/Qty so it stays linked!
                st.session_state['roster'] = pd.concat([st.session_state['roster'], pd.DataFrame([new_wep])], ignore_index=True)
                st.rerun()

        else:
            # Empty State (Right Panel)
            st.info("üëà Select a unit from the list to edit its loadout.")
            st.caption("Or click 'New Unit' to create a dataslate.")

# --- HELPER: GRADE-BASED STYLING ---
def style_cpk_by_grade(val):
    """
    Returns background color based on CPK grade.
    Maps S-tier (blue) to F-tier (red).
    """
    if pd.isna(val) or val >= 999:
        return 'background-color: #9E9E9E'  # Gray for invalid

    grade = get_cpk_grade(val)
    color = get_grade_color(grade)
    return f'background-color: {color}'

def get_cpk_background_colors(df_cpk):
    """
    Converts a dataframe of CPK values into a dataframe of background colors.
    Returns a dataframe with CSS background-color strings.
    """
    def cpk_to_color(val):
        if pd.isna(val) or val >= 999:
            return 'background-color: #9E9E9E'
        grade = get_cpk_grade(val)
        color = get_grade_color(grade)
        return f'background-color: {color}'

    # Use map instead of deprecated applymap
    try:
        return df_cpk.map(cpk_to_color)
    except AttributeError:
        # Fallback for older pandas versions
        return df_cpk.applymap(cpk_to_color)

# --- HELPER: BUILD METRICS TABLE ---
def build_metric_data(metric_key, include_cpk=False):
    """
    Returns TWO or THREE dataframes:
    1. df_values: The numeric stats (CPK, Kills, etc)
    2. df_tooltips: The text to show on hover (Active Profiles)
    3. df_cpk: (Optional) CPK values for styling purposes
    """
    data = {}
    tooltips = {}
    cpk_data = {} if include_cpk else None

    # Iterate through all targets (columns)
    for t_key, t_stats in TARGETS.items():
        # Calculate stats for this target
        # deduplicate=True ensures we see 1 Unit Efficiency (ignoring Qty)
        group_res = calculate_group_metrics(edited_df, t_stats, deduplicate=True)

        col_data = []
        col_tips = []
        col_cpk = [] if include_cpk else None
        index_names = []

        for g in group_res:
            label = f"{g['Unit']} [{g['Group']}]"
            index_names.append(label)

            col_data.append(g[metric_key])

            if include_cpk:
                col_cpk.append(g['CPK'])

            if g.get('Mode'):
                col_tips.append(f"Active: {g['Mode']}")
            else:
                col_tips.append("Standard Profile")

        data['Unit'] = index_names
        tooltips['Unit'] = index_names

        data[t_key] = col_data
        tooltips[t_key] = col_tips

        if include_cpk:
            cpk_data['Unit'] = index_names
            cpk_data[t_key] = col_cpk

    if not data:
        if include_cpk:
            return pd.DataFrame(), pd.DataFrame(), pd.DataFrame()
        return pd.DataFrame(), pd.DataFrame()

    df_values = pd.DataFrame(data).set_index('Unit')
    df_tips = pd.DataFrame(tooltips).set_index('Unit')

    if include_cpk:
        df_cpk = pd.DataFrame(cpk_data).set_index('Unit')
        return df_values, df_tips, df_cpk

    return df_values, df_tips

# --- METRIC TABS ---

with tab_cpk:
    st.caption("Lower is Better (Points Cost per Kill) - Color coded by efficiency grade")

    # Grade Legend
    with st.expander("üìä Grade Scale Reference"):
        col1, col2, col3, col4, col5, col6, col7 = st.columns(7)
        grades = [
            ('S', '‚â§1.0', '#2196F3', 'Elite'),
            ('A', '‚â§1.5', '#00D084', 'Excellent'),
            ('B', '‚â§2.0', '#4CAF50', 'Good'),
            ('C', '‚â§2.5', '#FFC107', 'Average'),
            ('D', '‚â§3.0', '#FF9800', 'Below Avg'),
            ('E', '‚â§3.5', '#FF5722', 'Poor'),
            ('F', '>3.5', '#F44336', 'Ineffective')
        ]
        for col, (grade, cpk_range, color, desc) in zip([col1, col2, col3, col4, col5, col6, col7], grades):
            with col:
                st.markdown(f"<div style='background-color:{color};padding:8px;border-radius:4px;text-align:center;'>"
                           f"<b>{grade}</b><br><small>{cpk_range}</small><br><small>{desc}</small></div>",
                           unsafe_allow_html=True)

    if not edited_df.empty:
        vals, tips = build_metric_data('CPK')
        if not vals.empty:
            # Active Weapon Profiles (Collapsible)
            with st.expander("üîß Active Weapon Profiles"):
                st.caption("Weapon profiles used for the calculations below (after profile optimization):")
                st.dataframe(tips, width='stretch', height=200)

            # The Main Table with Grade-Based Colors
            st.dataframe(
                vals.style.map(style_cpk_by_grade)
                          .format("{:.2f}"),
                width='stretch',
                height=500
            )

with tab_kills:
    st.caption("Higher is Better (Expected Kills per Activation) - Color coded by efficiency grade")

    # Grade Legend
    with st.expander("üìä Grade Scale Reference"):
        col1, col2, col3, col4, col5, col6, col7 = st.columns(7)
        grades = [
            ('S', '‚â§1.0', '#2196F3', 'Elite'),
            ('A', '‚â§1.5', '#00D084', 'Excellent'),
            ('B', '‚â§2.0', '#4CAF50', 'Good'),
            ('C', '‚â§2.5', '#FFC107', 'Average'),
            ('D', '‚â§3.0', '#FF9800', 'Below Avg'),
            ('E', '‚â§3.5', '#FF5722', 'Poor'),
            ('F', '>3.5', '#F44336', 'Ineffective')
        ]
        for col, (grade, cpk_range, color, desc) in zip([col1, col2, col3, col4, col5, col6, col7], grades):
            with col:
                st.markdown(f"<div style='background-color:{color};padding:8px;border-radius:4px;text-align:center;'>"
                           f"<b>{grade}</b><br><small>{cpk_range}</small><br><small>{desc}</small></div>",
                           unsafe_allow_html=True)

    if not edited_df.empty:
        vals, tips, cpk_vals = build_metric_data('Kills', include_cpk=True)
        if not vals.empty:
            # Active Weapon Profiles (Collapsible)
            with st.expander("üîß Active Weapon Profiles"):
                st.caption("Weapon profiles used for the calculations below (after profile optimization):")
                st.dataframe(tips, width='stretch', height=200)

            # Apply CPK-based styling to Kills table
            styles = get_cpk_background_colors(cpk_vals)
            st.dataframe(
                vals.style.apply(lambda _: styles, axis=None)
                          .format("{:.2f}"),
                width='stretch',
                height=500
            )

with tab_ttk:
    st.caption("Lower is Better (Activations required to wipe unit) - Color coded by efficiency grade")

    # Grade Legend
    with st.expander("üìä Grade Scale Reference"):
        col1, col2, col3, col4, col5, col6, col7 = st.columns(7)
        grades = [
            ('S', '‚â§1.0', '#2196F3', 'Elite'),
            ('A', '‚â§1.5', '#00D084', 'Excellent'),
            ('B', '‚â§2.0', '#4CAF50', 'Good'),
            ('C', '‚â§2.5', '#FFC107', 'Average'),
            ('D', '‚â§3.0', '#FF9800', 'Below Avg'),
            ('E', '‚â§3.5', '#FF5722', 'Poor'),
            ('F', '>3.5', '#F44336', 'Ineffective')
        ]
        for col, (grade, cpk_range, color, desc) in zip([col1, col2, col3, col4, col5, col6, col7], grades):
            with col:
                st.markdown(f"<div style='background-color:{color};padding:8px;border-radius:4px;text-align:center;'>"
                           f"<b>{grade}</b><br><small>{cpk_range}</small><br><small>{desc}</small></div>",
                           unsafe_allow_html=True)

    if not edited_df.empty:
        vals, tips, cpk_vals = build_metric_data('TTK', include_cpk=True)
        if not vals.empty:
            # Active Weapon Profiles (Collapsible)
            with st.expander("üîß Active Weapon Profiles"):
                st.caption("Weapon profiles used for the calculations below (after profile optimization):")
                st.dataframe(tips, width='stretch', height=200)

            # Apply CPK-based styling to TTK table
            styles = get_cpk_background_colors(cpk_vals)
            st.dataframe(
                vals.style.apply(lambda _: styles, axis=None)
                          .format("{:.2f}"),
                width='stretch',
                height=500
            )

# --- TAB 5: VISUALIZATIONS ---
with tab_viz:
    if edited_df.empty:
        st.info("Add units to see charts.")
    else:
        # 1. Select Theme
        c_theme, c_spacer = st.columns([1, 4])
        with c_theme:
            theme_names = list(THEMES.keys())
            selected_theme_name = st.selectbox("üé® Chart Theme", theme_names)
        
        # 2. Get Config from JSON
        theme_data = THEMES[selected_theme_name]
        chosen_template = theme_data.get("template", "plotly")
        chosen_palette = theme_data.get("colors", px.colors.qualitative.Bold)

        # 3. Generate Colors
        unit_colors = get_unit_color_map(edited_df, chosen_palette)
        
        # 4. Render Charts
        st.subheader(f"Analysis vs {selected_target_key}")
        
        c1, c2 = st.columns(2)
        with c1: st.plotly_chart(plot_threat_matrix_interactive(edited_df, unit_colors, chosen_template), width='stretch')
        with c2: st.plotly_chart(plot_efficiency_curve_interactive(edited_df, unit_colors, chosen_template), width='stretch')
        
        st.divider()
        
        c3, c4 = st.columns(2)
        with c3: st.plotly_chart(plot_strength_profile(edited_df, chosen_template), width='stretch')
        with c4: st.plotly_chart(plot_army_damage(edited_df, unit_colors, chosen_template), width='stretch')